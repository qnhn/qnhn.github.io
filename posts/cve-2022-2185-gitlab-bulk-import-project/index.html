<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gitlab Remote Code Execution via Bulk Import Import Project - CVE-2022-2185 | blog.undo.pw</title><meta name=keywords content="cve,gitlab,rce"><meta name=description content="Detail analysis of CVE-2022-2185"><meta name=author content="son"><link rel=canonical href=https://blog.undo.pw/posts/cve-2022-2185-gitlab-bulk-import-project/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.undo.pw/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.undo.pw/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.undo.pw/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.undo.pw/apple-touch-icon.png><link rel=mask-icon href=https://blog.undo.pw/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Gitlab Remote Code Execution via Bulk Import Import Project - CVE-2022-2185"><meta property="og:description" content="Detail analysis of CVE-2022-2185"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.undo.pw/posts/cve-2022-2185-gitlab-bulk-import-project/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-10T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gitlab Remote Code Execution via Bulk Import Import Project - CVE-2022-2185"><meta name=twitter:description content="Detail analysis of CVE-2022-2185"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.undo.pw/posts/"},{"@type":"ListItem","position":2,"name":"Gitlab Remote Code Execution via Bulk Import Import Project - CVE-2022-2185","item":"https://blog.undo.pw/posts/cve-2022-2185-gitlab-bulk-import-project/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gitlab Remote Code Execution via Bulk Import Import Project - CVE-2022-2185","name":"Gitlab Remote Code Execution via Bulk Import Import Project - CVE-2022-2185","description":"Detail analysis of CVE-2022-2185","keywords":["cve","gitlab","rce"],"articleBody":"Brief CVE description Lỗ hổng CVE-2022-2185 cho phép authenticated user có quyền import project thực hiện import một project bị chỉnh sửa có yếu tố độc hại có thể dẫn đến thực thi các command nguy hiểm trên hệ thống chạy Gitlab sử dụng các phiên bản bị ảnh hưởng.\nDanh sách các phiên bản bị ảnh hưởng:\n\u003e=14.0, \u003c14.10.5 \u003e=15.0, \u003c15.0.4 \u003e=15.1, \u003c15.1.1 Điểm CVSS 3.1: 9.9 (CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H).\nAdvisory: https://about.gitlab.com/releases/2022/06/30/critical-security-release-gitlab-15-1-1-released/#remote-command-execution-via-project-imports\nCommit: https://gitlab.com/gitlab-org/gitlab/-/commit/fae2720ffd7ec5ce3eb88e3b68b2879f4f664cf4\nMitigation Upgrade lên phiên bản mới nhất của Gitlab. Phân quyền người dùng chặt chẽ, hạn chế tối đa quyền hạn của người dùng có thể sử dụng các tính năng không cần thiết. Yêu cầu người dùng sử dụng mật khẩu mạnh. Analysis Sau khi đọc advisory và commit, ta nhận biết được rằng đây là lỗi Command Injection và đoạn code lỗi nằm ở class ImportExport::DecompressedArchiveSizeValidator.\nChúng ta có thể thấy rằng Gitlab đã thêm hàm validate_archive_path (dùng để validate @archive_path có phải là một đường dẫn trỏ đến 1 tập tin hợp lệ hay không) ngay trước khi chạy vào đoạn code thực thi command.\nBiến @archive_path được đưa trực tiếp vào giá trị của command như hình dưới đây:\nTừ đó, ta thấy được rằng chúng ta cần phải tìm cách control được @archive_path thành input của ta để có thể execute arbitrary command.\nClass DecompressedArchiveSizeValidator được sử dụng trong 2 modules là:\nBulkImports::FileDecompressionService ImportExport::FileImporter Sau quá trình review code, ta thấy rằng để control được @archive_path, ta cần phải control được project.import_source từ ImportExport::Importer. Code flow của chúng ta như sau:\nTheo như commit thì lỗi có liên quan đến phần xử lí cho bulk import nên ta sẽ tập trung vào module này nhiều hơn.\nDiff commit review Sau khi nhìn qua commit, có vài điểm đáng lưu ý sau đây:\nlib/bulk_imports/projects/transformers/project_attributes_transformer.rb spec/lib/bulk_imports/projects/transformers/project_attributes_transformer_spec.rb Tại 2 file này, chúng ta có thể thấy Gitlab fix cứng việc truyền data thông qua GraphQL, ngăn chặn việc thêm bớt key bằng cách:\nTạo 1 hash mới tên project Thêm từng attribute có dạng symbol vào project Trả về biến project thay vì trả về trực tiếp dữ liệu từ biến data =\u003e Chúng ta có thể control được dữ liệu này để làm những bước tiếp theo.\nDebugging Để thuận tiện cho việc debug, chúng ta cần cho phép Gitlab truy cập vào các địa chỉ IP trong local bằng cách vào Admin Panel -\u003e Settings -\u003e Network, tại “Outbound requests” section, chọn vào “Allow requests to the local network from web hooks and services”.\nChúng ta hãy bắt đầu bằng việc khởi tạo 1 bulk import session.\nChọn bất kì repo nào cần import và bấm Import. Request có dạng như sau:\nPOST /import/bulk_imports.json HTTP/1.1 Host: gdk.test:3000 Cookie: [REDACTED] Content-Type: application/json Content-Length: 155 Connection: close {\"bulk_import\":[{\"source_type\":\"group_entity\",\"source_full_path\":\"gitlab-org\",\"destination_namespace\":\"gitlab-org\",\"destination_name\":\"aaa\"}]} Tại file app/models/bulk_imports/entity.rb, ta thấy chức năng bulk import có hỗ trợ import project bằng cách đổi source_type thành project_entity.\nVới POST data như hình trên, ta đang thực hiện import project gitlab-org/gitlab-test để tạo ra project gitlab-org/aaa.\nĐặt breakpoint tại hàm create trong app/controllers/import/bulk_imports_controller.rb. Khi request vào endpoint trên thì chương trình sẽ dừng tại breakpoint mình vừa đặt tại đây.\nBulkImports::CreateService.execute thực hiện chức năng import project bằng cách thực thi BulkImportWorker.perform_async.\nClass method perform_async gọi đến instance method perform của class BulkImportWorker.\nTrong phương thức này, có 1 dòng gọi tới class BulkImports::CreatePipelineTrackersService, class này lặp qua các pipelines được định nghĩa trong lib/bulk_imports/projects/stage.rb.\nMục đích dùng để kiểm tra xem pipeline nào phù hợp để thêm vào tracker nhằm thực hiện chức năng import.\nNhững pipeline này được thực hiện tuần tự bởi BulkImports::Pipeline::Runner. Cụ thể như hình dưới đây:\nNhiệm vụ của Runner là lặp qua từng extractor, transformer và loader của pipeline để xử lí. Dữ liệu được lấy từ extractor sẽ được truyền vào cho các transformers xử lí và dữ liệu sau khi qua transformer sẽ được đưa vào loader.\nDigging into the root cause ProjectPipeline là pipeline đầu tiên được đi vào. Lần lượt đi vào các extractor và transformer như đã khai báo:\nGraphqlExtractor được gọi với tham số query - là kết quả của Graphql::GetProjectQuery dùng để lấy dữ liệu từ GraphQL endpoint của Gitlab. ProhibitedAttributesTransformer lặp qua các attribute trong dữ liệu để bỏ đi những attribute không cho phép. ProjectAttributesTransformer cũng chính là transformer đã xuất hiện trong commit sửa lỗi của Gitlab. Nhiệm vụ chính của transformer này là để tạo một dữ liệu mới chứa những thông tin cần thiết, phục vụ cho các pipeline tiếp theo. Ở đây, biến data chính là dữ liệu được lấy từ GraphqlExtractor ở trên. Sau khi khởi tạo các attribute cần thiết cho biến data, data.transform_keys!(\u0026:to_sym) sẽ tiến hành transform các keys trong biến thành kiểu Symbol. Như ta thấy, biến data đã được thêm các attributes mới như name, path, import_type, visibility_level và namespace_id. Sau khi hoàn thành xong các extractor và transformer, chúng ta sẽ được nhảy vào hàm load để tiếp tục. Projects::CreateService.execute sẽ được thực thi với tham số data ở trên.\nĐể có thể từ Projects::CreateService với import_type là gitlab_project_migration chạy đến ImportExport::Importer, ta search class này trong codebase để xem class này được dùng ở đâu.\nVậy là ImportExport::Importer được dùng với type là gitlab_project.\nTại phương thức import_schedule, @project.import_state.schedule được chạy để thực hiện tạo schedule cho import job khi thỏa mãn các điều kiện, có một điều kiện là attribute import_type không phải là gitlab_project_migration.\nĐể có thể làm được điều này, đầu phương thức execute của có sử dụng class Projects::CreateFromTemplateService để thực hiện chức năng tạo project dựa trên một built-in template được mô tả tại đây.\nĐi sâu vào class Projects::CreateFromTemplateService, chúng ta có thể thấy được phương thức thực hiện thay đổi attribute import_type tại Projects::GitlabProjectsImportService.prepare_import_params.\nSau khi hoàn thành prepare_import_params, nó sẽ tiến tục chạy Projects::CreateService một lần nữa với tham số params mới có attribute import_type là gitlab_project.\nSơ đồ của flow như sau:\nQuay trở lại lúc lần đầu tiên chạy vào Projects::CreateService, điều kiện create_from_template? được định nghĩa như sau\nKiểm tra nếu 1 trong 2 attributes là :template_name và :template_project_id có xuất hiện trong dữ liệu truyền vào Project::CreateService.\nNhư vậy tổng kết lại cả bài viết, những bước exploit của chúng ta như sau:\nTạo 1 web proxy đứng trước 1 Gitlab server. Cho Gitlab connect vào web proxy của ta. Thực hiện request import project qua tính năng Bulk import. Sửa response (đúng) trả về từ Gitlab của ta để server nhận được response (đã sửa đổi) với attribute mà ta truyền vào. RCE! Nhưng còn đó một điều đặc biệt ở lỗi này, nằm ở ImportExport::FileImporter.\nTrước khi đi vào phương thức validate_decompressed_archive_size để thực thi command, nó đi vào phương thức wait_for_archived_file trước.\nPhương thức này sẽ tiếp tục chương trình nếu @archive_file là một đường dẫn file hợp lệ và tồn tại trên hệ thống, ngược lại thì sẽ thử lại 8 lần, mỗi lần sleep 2n giây, với n là số lần đã thử.\nSau đó, phương thức này không thực hiện kết thúc mà dùng yield để thực hiện các đoạn code trong block do..end nên chúng ta vẫn thực hiện được phương thức validate_decompressed_archive_size như bình thường.\nKhi exploiting, @archive_file của ta lúc này không phải là một file hợp lệ nữa nên ta cần đợi 28 - 1 = 255 giây thì chương trình mới tiếp tục.\nResults Kết quả sau khi chờ 0xff giây:\n","wordCount":"1246","inLanguage":"en","datePublished":"2022-08-10T00:00:00Z","dateModified":"2022-08-10T00:00:00Z","author":{"@type":"Person","name":"son"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.undo.pw/posts/cve-2022-2185-gitlab-bulk-import-project/"},"publisher":{"@type":"Organization","name":"blog.undo.pw","logo":{"@type":"ImageObject","url":"https://blog.undo.pw/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.undo.pw/ accesskey=h title="blog.undo.pw (Alt + H)">blog.undo.pw</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.undo.pw/archives title=archives><span>archives</span></a></li><li><a href=https://blog.undo.pw/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.undo.pw/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.undo.pw/>Home</a>&nbsp;»&nbsp;<a href=https://blog.undo.pw/posts/>Posts</a></div><h1 class=post-title>Gitlab Remote Code Execution via Bulk Import Import Project - CVE-2022-2185</h1><div class=post-meta><span title='2022-08-10 00:00:00 +0000 UTC'>August 10, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;son&nbsp;|&nbsp;<a href=https://github.com/qnhn/qnhn.github.io/tree/main/content/posts/cve-2022-2185-gitlab-bulk-import-project.md rel="noopener noreferrer" target=_blank>suggest changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#brief-cve-description>Brief CVE description</a></li><li><a href=#mitigation>Mitigation</a></li><li><a href=#analysis>Analysis</a></li><li><a href=#diff-commit-review>Diff commit review</a></li><li><a href=#debugging>Debugging</a></li><li><a href=#digging-into-the-root-cause>Digging into the root cause</a><ul><li><a href=#results>Results</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=brief-cve-description>Brief CVE description<a hidden class=anchor aria-hidden=true href=#brief-cve-description>#</a></h2><p>Lỗ hổng CVE-2022-2185 cho phép authenticated user có quyền import project thực hiện import một project bị chỉnh sửa có yếu tố độc hại có thể dẫn đến thực thi các command nguy hiểm trên hệ thống chạy Gitlab sử dụng các phiên bản bị ảnh hưởng.</p><p>Danh sách các phiên bản bị ảnh hưởng:</p><ul><li>>=14.0, &lt;14.10.5</li><li>>=15.0, &lt;15.0.4</li><li>>=15.1, &lt;15.1.1</li></ul><p>Điểm CVSS 3.1: <code>9.9</code> (<code>CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H</code>).</p><p>Advisory: <a href=https://about.gitlab.com/releases/2022/06/30/critical-security-release-gitlab-15-1-1-released/#remote-command-execution-via-project-imports>https://about.gitlab.com/releases/2022/06/30/critical-security-release-gitlab-15-1-1-released/#remote-command-execution-via-project-imports</a></p><p>Commit: <a href=https://gitlab.com/gitlab-org/gitlab/-/commit/fae2720ffd7ec5ce3eb88e3b68b2879f4f664cf4>https://gitlab.com/gitlab-org/gitlab/-/commit/fae2720ffd7ec5ce3eb88e3b68b2879f4f664cf4</a></p><h2 id=mitigation>Mitigation<a hidden class=anchor aria-hidden=true href=#mitigation>#</a></h2><ul><li>Upgrade lên phiên bản mới nhất của Gitlab.</li><li>Phân quyền người dùng chặt chẽ, hạn chế tối đa quyền hạn của người dùng có thể sử dụng các tính năng không cần thiết.</li><li>Yêu cầu người dùng sử dụng mật khẩu mạnh.</li></ul><h2 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h2><p>Sau khi đọc advisory và commit, ta nhận biết được rằng đây là lỗi Command Injection và đoạn code lỗi nằm ở class <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/gitlab/import_export/decompressed_archive_size_validator.rb>ImportExport::DecompressedArchiveSizeValidator</a>.</p><p><img loading=lazy src=https://i.imgur.com/vvINNfy.png alt></p><p>Chúng ta có thể thấy rằng Gitlab đã thêm hàm <code>validate_archive_path</code> (dùng để validate <code>@archive_path</code> có phải là một đường dẫn trỏ đến 1 tập tin hợp lệ hay không) ngay trước khi chạy vào đoạn code thực thi command.</p><p>Biến <code>@archive_path</code> được đưa trực tiếp vào giá trị của <code>command</code> như hình dưới đây:</p><p><img loading=lazy src=https://i.imgur.com/6Bbr8pl.png alt></p><p>Từ đó, ta thấy được rằng chúng ta cần phải tìm cách control được <code>@archive_path</code> thành input của ta để có thể execute arbitrary command.</p><p>Class <code>DecompressedArchiveSizeValidator</code> được sử dụng trong 2 modules là:</p><ul><li><a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/app/services/bulk_imports/file_decompression_service.rb>BulkImports::FileDecompressionService</a></li><li><a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/gitlab/import_export/file_importer.rb>ImportExport::FileImporter</a></li></ul><p>Sau quá trình review code, ta thấy rằng để control được <code>@archive_path</code>, ta cần phải control được <code>project.import_source</code> từ <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/gitlab/import_export/importer.rb#L14>ImportExport::Importer</a>. Code flow của chúng ta như sau:</p><p><img loading=lazy src=https://i.imgur.com/ItxyjTJ.png alt></p><p>Theo như commit thì lỗi có liên quan đến phần xử lí cho bulk import nên ta sẽ tập trung vào module này nhiều hơn.</p><p><img loading=lazy src=https://i.imgur.com/IKaMc9R.png alt></p><h2 id=diff-commit-review>Diff commit review<a hidden class=anchor aria-hidden=true href=#diff-commit-review>#</a></h2><p>Sau khi nhìn qua commit, có vài điểm đáng lưu ý sau đây:</p><p><em>lib/bulk_imports/projects/transformers/project_attributes_transformer.rb</em>
<img loading=lazy src=https://i.imgur.com/di0H5W1.png alt></p><p><em>spec/lib/bulk_imports/projects/transformers/project_attributes_transformer_spec.rb</em>
<img loading=lazy src=https://i.imgur.com/AouKMo7.png alt></p><p>Tại 2 file này, chúng ta có thể thấy Gitlab fix cứng việc truyền data thông qua GraphQL, ngăn chặn việc thêm bớt key bằng cách:</p><ol><li>Tạo 1 hash mới tên <code>project</code></li><li>Thêm từng attribute có dạng symbol vào <code>project</code></li><li>Trả về biến <code>project</code> thay vì trả về trực tiếp dữ liệu từ biến <code>data</code></li></ol><p>=> Chúng ta có thể control được dữ liệu này để làm những bước tiếp theo.</p><h2 id=debugging>Debugging<a hidden class=anchor aria-hidden=true href=#debugging>#</a></h2><p>Để thuận tiện cho việc debug, chúng ta cần cho phép Gitlab truy cập vào các địa chỉ IP trong local bằng cách vào Admin Panel -> Settings -> Network, tại &ldquo;Outbound requests&rdquo; section, chọn vào &ldquo;Allow requests to the local network from web hooks and services&rdquo;.</p><p><img loading=lazy src=https://i.imgur.com/t0s6iPC.png alt></p><p>Chúng ta hãy bắt đầu bằng việc khởi tạo 1 bulk import session.</p><p><img loading=lazy src=https://i.imgur.com/7hZT2Su.png alt></p><p>Chọn bất kì repo nào cần import và bấm <code>Import</code>. Request có dạng như sau:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>POST /import/bulk_imports.json HTTP/1.1
</span></span><span style=display:flex><span>Host: gdk.test:3000
</span></span><span style=display:flex><span>Cookie: [REDACTED]
</span></span><span style=display:flex><span>Content-Type: application/json
</span></span><span style=display:flex><span>Content-Length: 155
</span></span><span style=display:flex><span>Connection: close
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{&#34;bulk_import&#34;:[{&#34;source_type&#34;:&#34;group_entity&#34;,&#34;source_full_path&#34;:&#34;gitlab-org&#34;,&#34;destination_namespace&#34;:&#34;gitlab-org&#34;,&#34;destination_name&#34;:&#34;aaa&#34;}]}
</span></span></code></pre></div><p>Tại file <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/app/models/bulk_imports/entity.rb#L92-99>app/models/bulk_imports/entity.rb</a>, ta thấy chức năng bulk import có hỗ trợ import project bằng cách đổi <code>source_type</code> thành <code>project_entity</code>.</p><p><img loading=lazy src=https://i.imgur.com/HgDMBbV.png alt></p><p><img loading=lazy src=https://i.imgur.com/WioKIEE.png alt></p><p>Với POST data như hình trên, ta đang thực hiện import project <code>gitlab-org/gitlab-test</code> để tạo ra project <code>gitlab-org/aaa</code>.</p><p>Đặt breakpoint tại hàm <code>create</code> trong <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/app/controllers/import/bulk_imports_controller.rb#L43-47>app/controllers/import/bulk_imports_controller.rb</a>. Khi request vào endpoint trên thì chương trình sẽ dừng tại breakpoint mình vừa đặt tại đây.</p><p><img loading=lazy src=https://i.imgur.com/mxaJ0sF.png alt></p><p><code>BulkImports::CreateService.execute</code> thực hiện chức năng import project bằng cách thực thi <code>BulkImportWorker.perform_async</code>.</p><p><img loading=lazy src=https://i.imgur.com/ntNvjst.png alt></p><p>Class method <code>perform_async</code> gọi đến instance method <code>perform</code> của class <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/app/workers/bulk_import_worker.rb#L12-36>BulkImportWorker</a>.</p><p><img loading=lazy src=https://i.imgur.com/m9N4Eb8.png alt></p><p>Trong phương thức này, có 1 dòng gọi tới class <code>BulkImports::CreatePipelineTrackersService</code>, class này lặp qua các pipelines được định nghĩa trong <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/bulk_imports/projects/stage.rb>lib/bulk_imports/projects/stage.rb</a>.</p><p><img loading=lazy src=https://i.imgur.com/WsSDWkI.png alt></p><p>Mục đích dùng để kiểm tra xem pipeline nào phù hợp để thêm vào tracker nhằm thực hiện chức năng import.</p><p><img loading=lazy src=https://i.imgur.com/bZ20Fyv.png alt></p><p>Những pipeline này được thực hiện tuần tự bởi <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/bulk_imports/pipeline/runner.rb>BulkImports::Pipeline::Runner</a>. Cụ thể như hình dưới đây:</p><p><img loading=lazy src=https://i.imgur.com/bgwqc1S.png alt></p><p>Nhiệm vụ của Runner là lặp qua từng extractor, transformer và loader của pipeline để xử lí. Dữ liệu được lấy từ extractor sẽ được truyền vào cho các transformers xử lí và dữ liệu sau khi qua transformer sẽ được đưa vào loader.</p><p><img loading=lazy src=https://i.imgur.com/9BemqfM.png alt></p><h2 id=digging-into-the-root-cause>Digging into the root cause<a hidden class=anchor aria-hidden=true href=#digging-into-the-root-cause>#</a></h2><p><a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/bulk_imports/projects/pipelines/project_pipeline.rb>ProjectPipeline</a> là pipeline đầu tiên được đi vào. Lần lượt đi vào các extractor và transformer như đã khai báo:</p><ul><li><a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/bulk_imports/common/extractors/graphql_extractor.rb>GraphqlExtractor</a> được gọi với tham số <code>query</code> - là kết quả của <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/bulk_imports/projects/graphql/get_project_query.rb>Graphql::GetProjectQuery</a> dùng để lấy dữ liệu từ GraphQL endpoint của Gitlab.
<img loading=lazy src=https://i.imgur.com/VvDsIZh.png alt></li><li><a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/bulk_imports/common/transformers/prohibited_attributes_transformer.rb>ProhibitedAttributesTransformer</a> lặp qua các attribute trong dữ liệu để bỏ đi những attribute không cho phép.
<img loading=lazy src=https://i.imgur.com/7JwVRx1.png alt></li><li><a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/bulk_imports/projects/transformers/project_attributes_transformer.rb>ProjectAttributesTransformer</a> cũng chính là transformer đã xuất hiện trong commit sửa lỗi của Gitlab. Nhiệm vụ chính của transformer này là để tạo một dữ liệu mới chứa những thông tin cần thiết, phục vụ cho các pipeline tiếp theo.
<img loading=lazy src=https://i.imgur.com/rHbraIp.png alt>
Ở đây, biến data chính là dữ liệu được lấy từ <code>GraphqlExtractor</code> ở trên.
<img loading=lazy src=https://i.imgur.com/fyY7j3Q.png alt>
Sau khi khởi tạo các attribute cần thiết cho biến data, <code>data.transform_keys!(&:to_sym)</code> sẽ tiến hành transform các keys trong biến thành kiểu Symbol.
<img loading=lazy src=https://i.imgur.com/ZzGJfW7.png alt>
Như ta thấy, biến data đã được thêm các attributes mới như <code>name</code>, <code>path</code>, <code>import_type</code>, <code>visibility_level</code> và <code>namespace_id</code>.</li></ul><p>Sau khi hoàn thành xong các extractor và transformer, chúng ta sẽ được nhảy vào hàm <code>load</code> để tiếp tục. <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/app/services/projects/create_service.rb#L24-91>Projects::CreateService.execute</a> sẽ được thực thi với tham số <code>data</code> ở trên.</p><p><img loading=lazy src=https://i.imgur.com/9fYthq6.png alt></p><p>Để có thể từ <code>Projects::CreateService</code> với <code>import_type</code> là <code>gitlab_project_migration</code> chạy đến <code>ImportExport::Importer</code>, ta search class này trong codebase để xem class này được dùng ở đâu.</p><p><img loading=lazy src=https://i.imgur.com/zvg2xhy.png alt></p><p>Vậy là <code>ImportExport::Importer</code> được dùng với type là <code>gitlab_project</code>.</p><p><img loading=lazy src=https://i.imgur.com/BBBtrtJ.png alt></p><p>Tại phương thức <code>import_schedule</code>, <code>@project.import_state.schedule</code> được chạy để thực hiện tạo schedule cho import job khi thỏa mãn các điều kiện, có một điều kiện là attribute <code>import_type</code> không phải là <code>gitlab_project_migration</code>.</p><p>Để có thể làm được điều này, đầu phương thức <code>execute</code> của có sử dụng class <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/app/services/projects/create_from_template_service.rb>Projects::CreateFromTemplateService</a> để thực hiện chức năng tạo project dựa trên một built-in template được mô tả tại <a href=https://docs.gitlab.com/ee/user/project/working_with_projects.html#create-a-project-from-a-built-in-template>đây</a>.</p><p><img loading=lazy src=https://i.imgur.com/bKKdqIw.png alt></p><p>Đi sâu vào class <code>Projects::CreateFromTemplateService</code>, chúng ta có thể thấy được phương thức thực hiện thay đổi attribute <code>import_type</code> tại <code>Projects::GitlabProjectsImportService.prepare_import_params</code>.</p><p><img loading=lazy src=https://i.imgur.com/FHUzCIs.png alt></p><p>Sau khi hoàn thành <code>prepare_import_params</code>, nó sẽ tiến tục chạy <code>Projects::CreateService</code> một lần nữa với tham số <code>params</code> mới có attribute <code>import_type</code> là <code>gitlab_project</code>.</p><p>Sơ đồ của flow như sau:</p><p><img loading=lazy src=https://i.imgur.com/6OC7pyw.png alt></p><p>Quay trở lại lúc lần đầu tiên chạy vào <code>Projects::CreateService</code>, điều kiện <code>create_from_template?</code> được định nghĩa như sau</p><p><img loading=lazy src=https://i.imgur.com/IELfk2Y.png alt></p><p>Kiểm tra nếu 1 trong 2 attributes là <code>:template_name</code> và <code>:template_project_id</code> có xuất hiện trong dữ liệu truyền vào <code>Project::CreateService</code>.</p><p>Như vậy tổng kết lại cả bài viết, những bước exploit của chúng ta như sau:</p><ol><li>Tạo 1 web proxy đứng trước 1 Gitlab server.</li><li>Cho Gitlab connect vào web proxy của ta.</li><li>Thực hiện request import project qua tính năng Bulk import.</li><li>Sửa response (đúng) trả về từ Gitlab của ta để server nhận được response (đã sửa đổi) với attribute mà ta truyền vào.</li><li>RCE!</li></ol><p>Nhưng còn đó một điều đặc biệt ở lỗi này, nằm ở <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/v15.1.0-ee/lib/gitlab/import_export/file_importer.rb#L44-53>ImportExport::FileImporter</a>.</p><p><img loading=lazy src=https://i.imgur.com/sa1hLv9.png alt></p><p>Trước khi đi vào phương thức <code>validate_decompressed_archive_size</code> để thực thi command, nó đi vào phương thức <code>wait_for_archived_file</code> trước.</p><p><img loading=lazy src=https://i.imgur.com/egkXUfh.png alt></p><p>Phương thức này sẽ tiếp tục chương trình nếu <code>@archive_file</code> là một đường dẫn file hợp lệ và tồn tại trên hệ thống, ngược lại thì sẽ thử lại 8 lần, mỗi lần sleep 2<sup>n</sup> giây, với <em>n</em> là số lần đã thử.</p><p>Sau đó, phương thức này không thực hiện kết thúc mà dùng <code>yield</code> để thực hiện các đoạn code trong block <code>do..end</code> nên chúng ta vẫn thực hiện được phương thức <code>validate_decompressed_archive_size</code> như bình thường.</p><p>Khi exploiting, <code>@archive_file</code> của ta lúc này không phải là một file hợp lệ nữa nên ta cần đợi <code>2<sup>8</sup> - 1 = 255</code> giây thì chương trình mới tiếp tục.</p><h3 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h3><p>Kết quả sau khi chờ 0xff giây:</p><p><img loading=lazy src=https://i.imgur.com/MDnraan.png alt></p><p><img loading=lazy src=https://i.imgur.com/df0ZIcL.png alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.undo.pw/tags/cve/>cve</a></li><li><a href=https://blog.undo.pw/tags/gitlab/>gitlab</a></li><li><a href=https://blog.undo.pw/tags/rce/>rce</a></li></ul><nav class=paginav><a class=next href=https://blog.undo.pw/posts/cve-2022-26134-confluence-ognl-injection/><span class=title>Next »</span><br><span>Atlassian Confluence Server and Data Center - OGNL Injection - CVE-2022-26134</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.undo.pw/>blog.undo.pw</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>